import {
  core.int.parse {parse-hex},
  core.int.show {show-int},
  core.list {any, concat, for-each-E, for-each-EN, intercalate},
  core.rune,
  core.text {drop, format, singleton, split, take-N},
}

data error {
| JSON-String-Error(text)
}

define _is-hex-digit(r: rune): bool {
  any(
    [
      and(le-rune(`0`, r), le-rune(r, `9`)),
      and(le-rune(`a`, r), le-rune(r, `f`)),
      and(le-rune(`A`, r), le-rune(r, `F`)),
    ],
  )
}

define _unquote-text(t: text): except(error, list(text)) {
  match core.text.uncons(t) {
  | Error(_) =>
    OK([*"\\"])
  | OK(Pair(c, rest)) =>
    if eq-rune(c, `b`) {
      OK([*"\u{8}", rest])
    } else-if eq-rune(c, `t`) {
      OK([*"\u{9}", rest])
    } else-if eq-rune(c, `n`) {
      OK([*"\u{a}", rest])
    } else-if eq-rune(c, `f`) {
      OK([*"\u{c}", rest])
    } else-if eq-rune(c, `r`) {
      OK([*"\u{d}", rest])
    } else-if eq-rune(c, `"`) {
      OK([*"\u{22}", rest])
    } else-if eq-rune(c, `/`) {
      OK([*"\u{2f}", rest])
    } else-if eq-rune(c, `\\`) {
      OK([*"\u{5c}", rest])
    } else-if eq-rune(c, `u`) {
      let scalar-value-text on rest = take-N(rest, 4) in
      let len on scalar-value-text = core.text.length(scalar-value-text) in
      pin scalar-value-text = scalar-value-text in
      if and(eq-int(len, 4), core.text.all(scalar-value-text, _is-hex-digit)) {
        match parse-hex(scalar-value-text) {
        | Error(_) =>
          Error(JSON-String-Error(format("Could not parse `{}` as a hexadecimal integer", [*scalar-value-text])))
        | OK(v) =>
          match core.rune.from-int(v) {
          | Error(_) =>
            Error(JSON-String-Error(format("The value `{}` is outside of the Unicode codespace", [show-int(v)])))
          | OK(r) =>
            let rest' = drop(rest, 4) in
            OK([singleton(r), rest'])
          }
        }
      } else {
        Error(JSON-String-Error(format("Expected 4-digit Unicode codepoint, but got: {}", [*scalar-value-text])))
      }
    } else {
      Error(JSON-String-Error(format("Unknown escape sequence: \\{}", [singleton(c)])))
    }
  }
}

define _parse-json-text-fragment(t: &text): except(error, list(text)) {
  match split(t, "\\") {
  | Nil =>
    // unreachable
    Error(JSON-String-Error(*"json.text.parse._parse-json-text-fragment"))
  | Cons(t', ts') =>
    try fragment-lists = for-each-E(ts', _unquote-text) in
    OK(Cons(t', concat(fragment-lists)))
  }
}

define _parse-json-text(t: &text): except(error, text) {
  pin ts = split(t, "\\\\") in
  try tss = for-each-EN(ts, _parse-json-text-fragment) in
  OK(core.text.join(core.list.concat(intercalate(tss, [*"\\"]))))
}

define zen(): unit {
  match _parse-json-text("hello,\\u12abrld") {
  | Error(JSON-String-Error(e)) =>
    printf("error: {}\n", [e])
  | OK(t') =>
    printf("success: {}\n", [t'])
  }
}
