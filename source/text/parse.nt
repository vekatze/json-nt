import {
  core.int.parse {parse-hex},
  core.list {intercalate},
  core.rune,
  core.text {drop, format, singleton, split, take-N},
}

data error {
| Error(text)
}

define _is-hex-digit(r: rune): bool {
  any(
    [
      and(le-rune(`0`, r), le-rune(r, `9`)),
      and(le-rune(`a`, r), le-rune(r, `f`)),
      and(le-rune(`A`, r), le-rune(r, `F`)),
    ],
  )
}

define _unquote-text(t: text): either(error, list(text)) {
  match core.text.uncons(t) {
  | Left(_) =>
    Right([*"\\"])
  | Right(Pair(c, rest)) =>
    if eq-rune(c, `b`) {
      Right([*"\u{8}", rest])
    } else-if eq-rune(c, `t`) {
      Right([*"\u{9}", rest])
    } else-if eq-rune(c, `n`) {
      Right([*"\u{a}", rest])
    } else-if eq-rune(c, `f`) {
      Right([*"\u{c}", rest])
    } else-if eq-rune(c, `r`) {
      Right([*"\u{d}", rest])
    } else-if eq-rune(c, `"`) {
      Right([*"\u{22}", rest])
    } else-if eq-rune(c, `/`) {
      Right([*"\u{2f}", rest])
    } else-if eq-rune(c, `\\`) {
      Right([*"\u{5c}", rest])
    } else-if eq-rune(c, `u`) {
      let scalar-value-text on rest = take-N(rest, 4) in
      let len on scalar-value-text = core.text.length(scalar-value-text) in
      pin scalar-value-text = scalar-value-text in
      if and(eq-int(len, 4), core.text.all(scalar-value-text, _is-hex-digit)) {
        match parse-hex(scalar-value-text) {
        | Left(_) =>
          Left(Error(format("Could not parse `{}` as a hexadecimal integer", [*scalar-value-text])))
        | Right(v) =>
          match core.rune.from-int(v) {
          | Left(_) =>
            Left(Error(format("The value `{}` is outside of the Unicode codespace", [%ld(v)])))
          | Right(r) =>
            let rest' = drop(rest, 4) in
            Right([singleton(r), rest'])
          }
        }
      } else {
        Left(Error(format("Expected 4-digit Unicode codepoint, but got: {}", [*scalar-value-text])))
      }
    } else {
      Left(Error(format("Unknown escape sequence: \\{}", [singleton(c)])))
    }
  }
}

define _parse-json-text-fragment(t: &text): either(error, list(text)) {
  match split(t, "\\") {
  | Nil =>
    // unreachable
    Left(Error(*"json.text.parse._parse-json-text-fragment"))
  | Cons(t', ts') =>
    try fragment-lists = try-for-each(ts', _unquote-text) in
    Right(Cons(t', concat(fragment-lists)))
  }
}

define _parse-json-text(t: &text): either(error, text) {
  pin ts = split(t, "\\\\") in
  try tss = try-for-each-N(ts, _parse-json-text-fragment) in
  Right(core.text.join(core.list.concat(intercalate(tss, [*"\\"]))))
}

define zen(): unit {
  match _parse-json-text("hello,\\u12abrld") {
  | Left(Error(e)) =>
    printf("error: {}\n", [e])
  | Right(t') =>
    printf("success: {}\n", [t'])
  }
}
